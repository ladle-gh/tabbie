package grammar

import grammar.internal.Character
import grammar.internal.Junction
import grammar.internal.Multiple
import grammar.internal.Option
import grammar.internal.Sequence
import grammar.internal.Star
import grammar.internal.Switch
import grammar.internal.Symbol
import grammar.internal.Text
import grammar.internal.ZeroLengthSymbol

/**
 * A meaningful value generated by the listener that visited this token.
 * Caller must specify the type of the object before use.
 */
@Suppress("UNCHECKED_CAST")
fun <T> QualifiedToken.payload() = (this as ContextFreeToken).payload as T

/**
 * Provides a scope with the receiver as this if the substring is not empty.
 */
inline fun <T : PossiblyEmptyToken> T.ifPresent(block: T.() -> Unit) {
    if (isPresent()) {
        block(this)
    }
}

/**
 * A meaninful portion of input.
 * @property id the name of the rule that produced this token,
 * or an automatically-generated numeric ID if produced by an implicitly-defined rule
 * @property substring the matching substring of input
 */
sealed interface Token {
    val id: String
    val substring: String
}

/**
 * A non-literal token whose subtring may be empty.
 */
sealed interface PossiblyEmptyToken : Token {
    /**
     * Same as calling substring.isEmpty(), but more idiomatic.
     * @return true if one or more tokens were matches
     */
    fun isPresent(): Boolean

    /**
     * Same as calling substring.isNotEmpty(), but more idiomatic.
     * @return true if no tokens were matched
     */
    fun isNotPresent(): Boolean
}

/**
 * A token matching a single rule within a known set of rules.
 */
interface CollapsibleToken : Token {
    /**
     * @return the index of the specific rule matched
     */
    fun ordinal(): Int
}

/**
 * A token that has been given a payload.
 *
 * API Note: Distinction from [Token] is necessary to prevent [payload]
 * from being called before the payload property is assigned a value.
 */
sealed interface QualifiedToken : Token

/**
 * A token matching a [single other token][match].
 * @see JunctionToken
 * @see OptionToken
 */
sealed interface SingleMatchToken : Token {
    val match: QualifiedToken

    /**
     * Asserts [match] is a [SequenceToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun sequence(): QualifiedSequenceToken

    /**
     * Asserts [match] is a [JunctionToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun junction(): QualifiedJunctionToken

    /**
     * Asserts [match] is a [SequenceToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun multiple(): QualifiedMultipleToken

    /**
     * Asserts [match] is an [OptionToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun option(): QualifiedOptionToken

    /**
     * Asserts [match] is a [StarToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun star(): QualifiedStarToken

    /**
     * Asserts [match] is a [CharacterToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun character(): QualifiedCharacterToken

    /**
     * Asserts [match] is a [TextToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun text(): QualifiedTextToken

    /**
     * Asserts [match] is a [SwitchToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun switch(): QualifiedSwitchToken
}

/**
 * A [SingleMatchToken] with a payload.
 */
sealed interface QualifiedSingleMatchToken : SingleMatchToken, QualifiedToken {
    override val match: QualifiedToken
}

/**
 * A token matching [multiple other tokens][matches].
 * @see SequenceToken
 * @see MultipleToken
 * @see StarToken
 */
sealed interface MultiMatchToken : Token {
    val matches: List<QualifiedToken>

    /**
     * Asserts that all [matches] are [SequenceToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun sequences(): List<QualifiedSequenceToken>

    /**
     * Asserts that all [matches] are [JunctionToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun junctions(): List<QualifiedJunctionToken>

    /**
     * Asserts that all [matches] are [MultipleToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun multiples(): List<QualifiedMultipleToken>

    /**
     * Asserts that all [matches] are [OptionToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun options(): List<QualifiedOptionToken>

    /**
     * Asserts that all [matches] are [StarToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun stars(): List<QualifiedStarToken>

    /**
     * Asserts that all [matches] are [CharacterToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun characters(): List<QualifiedCharacterToken>

    /**
     * Asserts that all [matches] are [TextToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun texts(): List<QualifiedTextToken>

    /**
     * Asserts that all [matches] are [SwitchToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun switches(): List<QualifiedSwitchToken>
}

/**
 * A [MultiMatchToken] with a payload.
 */
sealed interface QualifiedMultiMatchToken : MultiMatchToken, QualifiedToken {
    override val matches: List<QualifiedToken>
}

/**
 * A token created by a sequence of other rules.
 */
sealed interface SequenceToken : MultiMatchToken {
    /**
     * Asserts that the match at the given index is a [SequenceToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun sequenceAt(index: Int): QualifiedSequenceToken

    /**
     * Asserts that the match at the given index is a [JunctionToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun junctionAt(index: Int): QualifiedJunctionToken

    /**
     * Asserts that the match at the given index is a [MultipleToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun multipleAt(index: Int): QualifiedMultipleToken

    /**
     * Asserts that the match at the given index is an [OptionToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun optionAt(index: Int): QualifiedOptionToken

    /**
     * Asserts that the match at the given index is a [StarToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun starAt(index: Int): QualifiedStarToken

    /**
     * Asserts that the match at the given index is a [CharacterToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun characterAt(index: Int): QualifiedCharacterToken

    /**
     * Asserts that the match at the given index is a [TextToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun textAt(index: Int): QualifiedTextToken

    /**
     * Asserts that the match at the given index is a [SwitchToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun switchAt(index: Int): QualifiedSwitchToken

    /**
     * @return the match at the given index as a context-free [Token].
     */
    operator fun get(index: Int): QualifiedToken
}

/**
 * A [SequenceToken] with a payload.
 */
sealed interface QualifiedSequenceToken : SequenceToken, QualifiedMultiMatchToken

/**
 * A token created by using the '|' operator.
 */
sealed interface JunctionToken : SingleMatchToken, CollapsibleToken {
    /**
     * @return the index of the rule that was matched
     */
    override fun ordinal(): Int
}

/**
 * A [JunctionToken] with a payload.
 */
sealed interface QualifiedJunctionToken : JunctionToken, QualifiedSingleMatchToken

/**
 * A token created by using the '?' operator.
 */
sealed interface OptionToken : SingleMatchToken, PossiblyEmptyToken

/**
 * A [OptionToken] with a payload.
 */
sealed interface QualifiedOptionToken : OptionToken, QualifiedSingleMatchToken

/**
 * A token created by using the '+' operator.
 */
sealed interface MultipleToken : MultiMatchToken

/**
 * A [MultipleToken] with a payload.
 */
sealed interface QualifiedMultipleToken : MultipleToken, QualifiedMultiMatchToken

/**
 * A token created by using the '*' operator.
 */
sealed interface StarToken : MultiMatchToken, PossiblyEmptyToken

/**
 * A [StarToken] with a payload.
 */
sealed interface QualifiedStarToken : StarToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a character literal (e.g. "a").
 */
sealed interface CharacterToken : Token {
    val charValue: Char
}

/**
 * A [CharacterToken] with a payload.
 */
sealed interface QualifiedCharacterToken : CharacterToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a text literal (e.g. "abc").
 */
sealed interface TextToken : Token {
    val stringValue: String
    val length: Int
}

/**
 * A [TextToken] with a payload.
 */
sealed interface QualifiedTextToken : TextToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a switch literal (e.g. \[abc]).
 */
sealed interface SwitchToken : Token, CollapsibleToken {
    val charValue: Char

    /**
     * @return the index of the range that was matched
     */
    override fun ordinal(): Int
}

/**
 * A [SwitchToken] with a payload.
 */
sealed interface QualifiedSwitchToken : SwitchToken, QualifiedMultiMatchToken

@Suppress("UNCHECKED_CAST")
internal fun <T> Token.thisAs(tokenName: String): T {
    val expect = tokenName.dropLast("Token".length)
    val actual = (this as ContextFreeToken).origin::class.simpleName
    if (actual == expect) {
        return this as T
    }
    throw TypeCastException("Listener type ($expect) does not agree with type of symbol ($actual)")
}

internal class ContextFreeToken(
    var origin: Symbol,
    override val substring: String = "",
    val children: List<ContextFreeToken> = listOf(),
    private val ordinal: Int = 0
) :
    QualifiedSequenceToken, QualifiedJunctionToken, QualifiedOptionToken, QualifiedMultipleToken,
    QualifiedStarToken, QualifiedCharacterToken, QualifiedTextToken, QualifiedSwitchToken
{
    override val id get() = origin.id
    var payload: Any? = null

    override val match get() = children[0]
    override val length get() = substring.length
    override val charValue get() = substring[0]
    override val stringValue get() = substring
    override val matches get() = children

    override fun ordinal() = ordinal
    override fun isPresent() = children.isNotEmpty()
    override fun isNotPresent() = children.isEmpty()

    override fun sequenceAt(index: Int) = getAs<Sequence,QualifiedSequenceToken>(index)
    override fun junctionAt(index: Int) = getAs<Junction,QualifiedJunctionToken>(index)
    override fun multipleAt(index: Int) = getAs<Multiple,QualifiedMultipleToken>(index)
    override fun optionAt(index: Int) = getAs<Option,QualifiedOptionToken>(index)
    override fun starAt(index: Int) = getAs<Star,QualifiedStarToken>(index)
    override fun characterAt(index: Int) = getAs<Character,QualifiedCharacterToken>(index)
    override fun textAt(index: Int) = getAs<Text,QualifiedTextToken>(index)
    override fun switchAt(index: Int) = getAs<Switch,QualifiedSwitchToken>(index)

    override fun get(index: Int) = children[index]

    override fun sequences() = getAllAs<Sequence,QualifiedSequenceToken>()
    override fun junctions() = getAllAs<Junction,QualifiedJunctionToken>()
    override fun multiples() = getAllAs<Multiple,QualifiedMultipleToken>()
    override fun options() = getAllAs<Option,QualifiedOptionToken>()
    override fun stars() = getAllAs<Star,QualifiedStarToken>()
    override fun characters() = getAllAs<Character,QualifiedCharacterToken>()
    override fun texts() = getAllAs<Text,QualifiedTextToken>()
    override fun switches() = getAllAs<Switch,QualifiedSwitchToken>()

    override fun sequence() = getSingleAs<Sequence,QualifiedSequenceToken>()
    override fun junction() = getSingleAs<Junction,QualifiedJunctionToken>()
    override fun multiple() = getSingleAs<Multiple,QualifiedMultipleToken>()
    override fun option() = getSingleAs<Option,QualifiedOptionToken>()
    override fun star() = getSingleAs<Star,QualifiedStarToken>()
    override fun character() = getSingleAs<Character,QualifiedCharacterToken>()
    override fun text() = getSingleAs<Text,QualifiedTextToken>()
    override fun switch() = getSingleAs<Switch,QualifiedSwitchToken>()

    fun <M> walk(listeners: Map<String, Token.(M) -> Any?>, mutableState: M) {
        children.forEach { it.walk(listeners, mutableState) } // Visit every node in tree
        payload = listeners[id]?.let {
             it(this, mutableState)
        } ?: when (origin) {
            is Sequence, is Multiple, is Star -> children.map { it.payload }    // .isEmpty() == .isNotPresent()
            is Junction, is Option -> children[0].payload   // (payload == null) == .isNotPresent()
            else -> null    // Useful information for literals is found in .substring, not .payload
        }
    }

    private inline fun <reified S : Symbol, reified T : QualifiedToken> getAs(index: Int): T {
        return try {
            children[index].origin as S
            children[index] as T
        } catch (e: IndexOutOfBoundsException) {
            throw IndexOutOfBoundsException("Match at index $index in calling SequenceToken does not exist")
        } catch (e: TypeCastException) {
            val s = S::class.simpleName
            throw TypeCastException("Match at index $index in calling SequenceToken is not derived from a $s")
        }
    }

    @Suppress("UNCHECKED_CAST")
    private inline fun <reified S : Symbol, reified T : QualifiedToken> getAllAs(): List<T> {
        var failureLocation = 0
        return try {
            for (child in children) {
                child.origin as S
                ++failureLocation
            }
            children as List<T>
        } catch (e: TypeCastException) {
            throw TypeCastException("Match at index $failureLocation is not derived from a  ${S::class.simpleName}")
        }
    }

    private inline fun <reified S : Symbol, reified T : QualifiedToken> getSingleAs(): T {
        return try {
            children[0].origin as S
            children[0] as T
        } catch (e: TypeCastException) {
            throw TypeCastException("Match at index 0 is not derived from a  ${S::class.simpleName}")
        }
    }

    companion object {
        val NOTHING = ContextFreeToken(ZeroLengthSymbol)
        val EMPTY = ContextFreeToken(ZeroLengthSymbol)
    }
}
